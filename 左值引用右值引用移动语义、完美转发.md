#1、左值右值
简单总结

> 左值：可以取地址并且有名字的东西就是左值。 
> 
> 右值：不能取地址的没有名字的东西就是右值。
> 
> 纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值。
> 
> 将亡值：可以理解为即将要销毁的值。
> 
> 左值引用：对左值进行引用的类型，其目的是为了避免对象的拷贝（函数传参、函数返回值）。
> 
> 右值引用：对右值进行引用的类型，其主要实现了移动语义和完美转发。
> 
> 移动语义：转移资源所有权，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。
> 
> 完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参。
> 
> 返回值优化：当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。

##左值、右值
**概念1**

左值：可以放到等号左边的东西叫左值。

右值：不可以放到等号左边的东西就叫右值。

**概念2**

左值：可以取地址并且有名字的东西就是左值。

右值：不能取地址的没有名字的东西就是右值。

左值一般有：

* 函数名和变量名
* 返回左值引用的函数调用
* 前置自增自减表达式++i、--i
* 由赋值表达式或赋值运算符连接的表达式(a=b, a += b等)
* 解引用表达式*p
* 字符串字面值"abcd"

纯右值一般有：

* 除字符串字面值外的字面值
* 返回非引用类型的函数调用
* 后置自增自减表达式i++、i--
* 算术表达式(a+b, a*b, a&&b, a==b等)
* 取地址表达式等(&a)

##左值引用、右值引用
    type &name = exp; //左值引用
    type &&name = exp; //右值引用

左值引用示例代码：

    int a = 5;
    int &b = a; // b是左值引用
    b = 4;
    int &c = 10; // error，10无法取地址，无法进行引用
    const int &d = 10; // ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址

右值引用示例代码：
> 如果使用右值引用，那表达式等号右边的值需要时右值，可以使用std::move函数强制把左值转换为右值。

    int a = 4;
    int &&b = a; // error, a是左值
    int &&c = std::move(a); // ok

##移动语义

> 移动语义，可以理解为转移所有权，之前的拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过C++11新增的移动语义可以省去很多拷贝负担，怎么利用移动语义呢，是通过移动构造函数。

代码示例：

    class A {
    public:
    A(int size) : size_(size) {
    	data_ = new int[size];
    }
    A(){}
    A(const A& a) {
    	size_ = a.size_;
    	data_ = new int[size_];
    	cout << "copy " << endl;
    }
    A(A&& a) {
    	this->data_ = a.data_;
    	a.data_ = nullptr;
    	cout << "move " << endl;
    }
    ~A() {
    	if (data_ != nullptr) {
     	delete[] data_;
    	}
    }
    int *data_;
    int size_;
    };

    int main() {
    A a(10);
    A b = a;
    A c = std::move(a); // 调用移动构造函数
    return 0;
    }
**注意：移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数。**

##完美转发
>完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，答案是使用std::forward()。

示例代码：

    void PrintV(int &t) {
   		 cout << "lvalue" << endl;
    }
    
    void PrintV(int &&t) {
   		 cout << "rvalue" << endl;
    }
    
    template<typename T>
    void Test(T &&t) {
    	PrintV(t);
    	PrintV(std::forward<T>(t));
    
    	PrintV(std::move(t));
    }
    
    int main() {
    	Test(1); // lvalue rvalue rvalue
    	int a = 1;
    	Test(a); // lvalue lvalue rvalue
    	Test(std::forward<int>(a)); // lvalue rvalue rvalue
    	Test(std::forward<int&>(a)); // lvalue lvalue rvalue
    	Test(std::forward<int&&>(a)); // lvalue rvalue rvalue
    	return 0;
    }
分析：

* Test(1)：1是右值，模板中T &&t这种为万能引用，右值1传到Test函数中变成了右值引用，但是调用PrintV()时候，t变成了左值，因为它变成了一个拥有名字的变量，所以打印lvalue，而PrintV(std::forward<T>(t))时候，会进行完美转发，按照原来的类型转发，所以打印rvalue，PrintV(std::move(t))毫无疑问会打印rvalue。

* Test(a)：a是左值，模板中T &&这种为万能引用，左值a传到Test函数中变成了左值引用，所以有代码中打印。

* Test(std::forward<T>(a))：转发为左值还是右值，依赖于T，T是左值那就转发为左值，T是右值那就转发为右值。

##返回值优化
返回值优化(RVO)是一种C++编译优化技术，当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。

那什么时候编译器会进行返回值优化呢?

* return的值类型与函数的返回值类型相同

* return的是一个局部对象

看几个例子:
示例1

    std::vector<int> return_vector(void) {
    	std::vector<int> tmp {1,2,3,4,5};
    	return tmp;
    }
    std::vector<int> &&rval_ref = return_vector();
不会触发RVO, 拷贝构造了一个临时的对象，临时对象的生命周期和rval_ref绑定，等价于下面这段代码：

    const std::vector<int>& rval_ref = return_vector();
示例2：

    std::vector<int> return_vector(void) {
    	std::vector<int> tmp {1,2,3,4,5};
    	return std::move(tmp);
    }
    
    std::vector<int> &&rval_ref = return_vector();
和示例1类似，std::move一个临时对象是没有必要的，也会忽略掉返回值优化。
触发代码：
    std::vector<int> return_vector(void){
    	std::vector<int> tmp {1,2,3,4,5};
    	return tmp;
    }
    std::vector<int> rval_ref = return_vector();
这段代码会触发RVO,不拷贝也不移动，不生成临时对象。